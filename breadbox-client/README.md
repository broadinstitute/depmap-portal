# The Breadbox Client

A client library for accessing Breadbox

Includes both an auto-generated `breadbox_client` module and a human-curated `breadbox_facade` which defines a more user-friendly interface for the client. 


## Auto-Generating the breadbox_client
When changes are merged to master, the `breadbox-client/breadbox_client` directory will be auto-generated before the breadbox-client module is published.

In general, the `breadbox_client` directory is auto-generated in a github action. It is not checked in to the repo.
When changes are merged to master, the `breadbox-client/breadbox_client` directory will be auto-generated before the breadbox-client module is published.

To generate the client for local development:
1. Make sure you have the `breadbox-client-generator` poetry project installed: 
    ```
    cd ../breadbox-client-generator
    poetry install
    ```
2. Generate the breadbox client:
    ```
    cd ../breadbox 
    poetry run ./bb update-client
    ```


## The breadbox Facade 

#### Includes improvements such as:

- **Simpler return types**. For example, the facade's get_datasets method returns `list[DatasetResponse]` instead of `Optional[Union[HTTPError, HTTPValidationError, List["DatasetResponse"]]]`
- **Better error handling**: Exceptions are raised instead of being returned
- **Constructors for custom types** For example, this facade accepts DataFrames instead of taking `breadbox_client.types.File` objects.
- **Better handling of None values** in cases where the autogenerated client wants to be given UNSET instead of None

## To publish a new version of this module:

**Option 1 (preferred)**: Merge your changes to the main branch. This module will be automatically updated and published. 

**Option 2**: Publish from local changes

To setup for publishing (Based on https://medium.com/google-cloud/python-packages-via-gcps-artifact-registry-ce1714f8e7c1 )

```
poetry self add keyrings.google-artifactregistry-auth
poetry config repositories.public-python https://us-central1-python.pkg.dev/cds-artifacts/public-python/
# also make sure you've authentication via "gcloud auth login" if you haven't already
```

And then you can bump the version and publish via:

```
poetry version patch
poetry publish --build --repository public-python
```

If this gives you an authentication error, you can investigate by running
the command again with debugging output by adding `-vvv`:

```
poetry publish --build --repository public-python -vvv
```

In the output, look for the list of keyring backends that are installed. The
below is an example of a working setup:

```
Checking if keyring is available
[keyring:keyring.backend] Loading Google Auth
[keyring:keyring.backend] Loading KWallet
[keyring:keyring.backend] Loading SecretService
[keyring:keyring.backend] Loading Windows
[keyring:keyring.backend] Loading chainer
[keyring:keyring.backend] Loading libsecret
[keyring:keyring.backend] Loading macOS
```

If `Loading Google Auth` is missing, you have a poetry environment problem
and the `poetry self add keyrings.google-artifactregistry-auth` is not
actually installing the library correctly. (I had this problem and I don't
fully understand the issue, but I suspect its because my `poetry` was
installed by brew and when using `poetry self ...` it's not updating the
environment in the right directory. `poetry self update` flat out aborts
saying it cannot do that when installed via brew.)

## Usage

### To install this module outside this repo:

```
poetry source add --priority=supplemental public-python https://us-central1-python.pkg.dev/cds-artifacts/public-python/simple/
poetry add --source public-python breadbox-client
```

First, create a client:

```python
from breadbox_facade import BBClient

client = BBClient(base_url="https://depmap.org/portal/breadbox/", user="someusername")


# If you're connnecting to the public portal or a local instance, you can now go ahead and use the client.
# For example:
datasets = client.get_datasets()
dimension_types = client.get_dimension_types()

# If you wanted to get the metadata for a particular gene, you could do something like:
df = client.get_tabular_dataset_data(
    dataset_id=dataset_id, # The ID of the gene metadata dataset
    columns=None,
    identifier="label",
    indices=[gene_name], # This will filter the result to just the gene you're interested in
    strict=True,
)
```

If the endpoints you're going to hit require authentication, use `AuthenticatedClient` instead:

```python
from breadbox_client import AuthenticatedClient

client = AuthenticatedClient(base_url="https://api.example.com", token="SuperSecretToken")
```

Now call your endpoint and use your models:

```python
from breadbox_client.models import MyDataModel
from breadbox_client.api.my_tag import get_my_data_model
from breadbox_client.types import Response

with client as client:
    my_data: MyDataModel = get_my_data_model.sync(client=client)
    # or if you need more info (e.g. status_code)
    response: Response[MyDataModel] = get_my_data_model.sync_detailed(client=client)
```

Or do the same thing with an async version:

```python
from breadbox_client.models import MyDataModel
from breadbox_client.api.my_tag import get_my_data_model
from breadbox_client.types import Response

async with client as client:
    my_data: MyDataModel = await get_my_data_model.asyncio(client=client)
    response: Response[MyDataModel] = await get_my_data_model.asyncio_detailed(client=client)
```

By default, when you're calling an HTTPS API it will attempt to verify that SSL is working correctly. Using certificate verification is highly recommended most of the time, but sometimes you may need to authenticate to a server (especially an internal server) using a custom certificate bundle.

```python
client = AuthenticatedClient(
    base_url="https://internal_api.example.com",
    token="SuperSecretToken",
    verify_ssl="/path/to/certificate_bundle.pem",
)
```

You can also disable certificate validation altogether, but beware that **this is a security risk**.

```python
client = AuthenticatedClient(
    base_url="https://internal_api.example.com",
    token="SuperSecretToken",
    verify_ssl=False
)
```

Things to know:

1. Every path/method combo becomes a Python module with four functions:

   1. `sync`: Blocking request that returns parsed data (if successful) or `None`
   1. `sync_detailed`: Blocking request that always returns a `Request`, optionally with `parsed` set if the request was successful.
   1. `asyncio`: Like `sync` but async instead of blocking
   1. `asyncio_detailed`: Like `sync_detailed` but async instead of blocking

1. All path/query params, and bodies become method arguments.
1. If your endpoint had any tags on it, the first tag will be used as a module name for the function (my_tag above)
1. Any endpoint which did not have a tag will be in `breadbox_client.api.default`

## Advanced customizations

There are more settings on the generated `Client` class which let you control more runtime behavior, check out the docstring on that class for more info. You can also customize the underlying `httpx.Client` or `httpx.AsyncClient` (depending on your use-case):

```python
from breadbox_client import Client

def log_request(request):
    print(f"Request event hook: {request.method} {request.url} - Waiting for response")

def log_response(response):
    request = response.request
    print(f"Response event hook: {request.method} {request.url} - Status {response.status_code}")

client = Client(
    base_url="https://api.example.com",
    httpx_args={"event_hooks": {"request": [log_request], "response": [log_response]}},
)

# Or get the underlying httpx client to modify directly with client.get_httpx_client() or client.get_async_httpx_client()
```

You can even set the httpx client directly, but beware that this will override any existing settings (e.g., base_url):

```python
import httpx
from breadbox_client import Client

client = Client(
    base_url="https://api.example.com",
)
# Note that base_url needs to be re-set, as would any shared cookies, headers, etc.
client.set_httpx_client(httpx.Client(base_url="https://api.example.com", proxies="http://localhost:8030"))
```

## Building / publishing this package

This project uses [Poetry](https://python-poetry.org/) to manage dependencies and packaging. Here are the basics:

1. Update the metadata in pyproject.toml (e.g. authors, version)
1. If you're using a private repository, configure it with Poetry
   1. `poetry config repositories.<your-repository-name> <url-to-your-repository>`
   1. `poetry config http-basic.<your-repository-name> <username> <password>`
1. Publish the client with `poetry publish --build -r <your-repository-name>` or, if for public PyPI, just `poetry publish --build`

If you want to install this client into another project without publishing it (e.g. for development) then:

1. If that project **is using Poetry**, you can simply do `poetry add <path-to-this-client>` from that project
1. If that project is not using Poetry:
   1. Build a wheel with `poetry build -f wheel`
   1. Install that wheel from the other project `pip install <path-to-wheel>`
